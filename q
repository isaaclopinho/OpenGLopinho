[1mdiff --git a/Project1/Game.cpp b/Project1/Game.cpp[m
[1mindex 819949c..d7ad3bc 100644[m
[1m--- a/Project1/Game.cpp[m
[1m+++ b/Project1/Game.cpp[m
[36m@@ -105,7 +105,7 @@[m [mGame* Game::GetInstance() {[m
 [m
 void Game::Run() {[m
 	[m
[31m-	states.push(new LevelState());[m
[32m+[m	[32mstates.push(new TestState());[m
 [m
 	[m
 [m
[1mdiff --git a/Project1/GameSrc/LevelState.h b/Project1/GameSrc/LevelState.h[m
[1mindex 8d05a91..f1fb563 100644[m
[1m--- a/Project1/GameSrc/LevelState.h[m
[1m+++ b/Project1/GameSrc/LevelState.h[m
[36m@@ -62,27 +62,30 @@[m [mclass LevelState : public State {[m
 [m
 public:[m
 	LevelState() : sfb(){ [m
[32m+[m[41m		[m
[32m+[m		[32m//Shadows and PostProcessing[m[41m[m
 		fbo = new Fbo(Game::GetInstance()->WIDTH, Game::GetInstance()->HEIGHT);[m
 		output = new Fbo(Game::GetInstance()->WIDTH, Game::GetInstance()->HEIGHT, 1);[m
 		pp = new PostProcessing();[m
 		pp->init();[m
[32m+[m		[32mMasterRenderer::GetInstance().usingShadow = true;[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
 		//Initialize Physics[m
 		btBroadphaseInterface* broadphase = new btDbvtBroadphase();[m
 		btDefaultCollisionConfiguration* collisionConfiguration = new btDefaultCollisionConfiguration();[m
 		btCollisionDispatcher* dispatcher = new btCollisionDispatcher(collisionConfiguration);[m
 		btSequentialImpulseConstraintSolver* solver = new btSequentialImpulseConstraintSolver;[m
[31m-[m
[31m-[m
[31m-		MasterRenderer::GetInstance().usingShadow = true;[m
 		phyWorld = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);[m
 		phyWorld->setGravity(btVector3(0, -9.8, 0));[m
 [m
 		//temporary physics ground for testing purposes[m
 		btCollisionShape* groundShape = new btStaticPlaneShape(btVector3(0, 1, 0), 0);[m
[31m-	[m
 		btDefaultMotionState* groundState = new btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), btVector3(0, 0, 0)));[m
 		btRigidBody::btRigidBodyConstructionInfo groundRBCI(0, groundState, groundShape, btVector3(0, 0, 0));[m
 		btRigidBody* groundRB = new btRigidBody(groundRBCI);[m
[32m+[m		[32mAddGameObject(new GameObjectTest(Entity(Loader::LoadModel("res/models/rua.obj"), glm::vec3(0, 0, 0), glm::vec3(0, 0, 0), 1, "", true)));[m[41m[m
[32m+[m		[32mAddGameObject(new GameObjectTest(Entity(Loader::LoadModel("res/models/casabrise.obj"), vec3(5, 0, 0), vec3(0, 0, 0), 1, "", false)));[m[41m[m
 [m
 		phyWorld->addRigidBody(groundRB);[m
 		[m
[36m@@ -91,14 +94,12 @@[m [mpublic:[m
 [m
 		player = Player::getInstance();[m
 		AddGameObject(player);[m
[31m-		camera.distanceFromTarget = 3;[m
[32m+[m		[32mcamera.distanceFromTarget = 7;[m[41m[m
 		camera.pitch = 30;[m
[31m-		camera.vDist = -5;[m
[32m+[m		[32mcamera.vDist = -13;[m[41m[m
 		camera.angleAroundTarget = 180;[m
 		phyWorld->addRigidBody(player->getRB());[m
 [m
[31m-		AddGameObject(new GameObjectTest(Entity(Loader::LoadModel("res/models/plane.dae"), glm::vec3(0, 0, 0), glm::vec3(-90, 0, 0), 25, "", true)));[m
[31m-[m
 [m
 		//debugDrawer->setDebugMode(btIDebugDraw::DBG_DrawWireframe);[m
 [m
[1mdiff --git a/Project1/GameSrc/Player.cpp b/Project1/GameSrc/Player.cpp[m
[1mindex 33c2939..f6813f3 100644[m
[1m--- a/Project1/GameSrc/Player.cpp[m
[1m+++ b/Project1/GameSrc/Player.cpp[m
[36m@@ -2,11 +2,13 @@[m
 #include <glm/gtx/rotate_vector.hpp>[m
 Player* Player::instance = 0;[m
 [m
[31m-Player::Player() : entity(Loader::LoadModel("res/Models/hans_mesh2.dae"), playerPos, playerRot, 0.05, "Walk", true)[m
[32m+[m[32mPlayer::Player() : entity(Loader::LoadModel("res/Models/hans_mesh2.dae"), playerPos, playerRot, 0.3, "Walk", true)[m
 {[m
[31m-	[m
[32m+[m	[32mbtTransform initTransform;[m
[32m+[m	[32minitTransform.setIdentity();[m
[32m+[m	[32minitTransform.setOrigin(btVector3(0, 10, 0));[m
 	//initialize physics[m
[31m-	btCollisionShape* playerCollider = new btBoxShape(btVector3(2, 0.05, 2));[m
[32m+[m	[32mbtConvexShape* playerCollider = new btCapsuleShape(0.05f, 0.03f);[m
 	btDefaultMotionState* playerMotion = new btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), Maths::glmToBullet(playerPos)));[m
 	btScalar playerMass = 1;[m
 	btVector3 playerFallInertia = btVector3(0, 0, 0);[m
[36m@@ -18,8 +20,8 @@[m [mPlayer::Player() : entity(Loader::LoadModel("res/Models/hans_mesh2.dae"), player[m
 	canJump = true;[m
 	jumpTimeStamp = 0;[m
 	jumpCoolDown = 2000;[m
[31m-	maxSpeed = 5;[m
[31m-	maxMoveForce = 2;[m
[32m+[m	[32mmaxSpeed = 10;[m
[32m+[m	[32mmaxMoveForce = 3;[m
 	turnAngle = 0.0;[m
 [m
 }[m
[36m@@ -112,7 +114,7 @@[m [mvoid Player::PlayerMove(float horizontalInput, float verticalInput, int newRot)[m
 [m
 void Player::PlayerJump() {[m
 [m
[31m-	playerRigidBody->applyCentralImpulse(btVector3(0, 4, 0));[m
[32m+[m	[32mplayerRigidBody->applyCentralImpulse(btVector3(0, 8, 0));[m
 	jumpTimeStamp = SDL_GetTicks();[m
 }[m
 [m
